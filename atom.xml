<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Write down &amp; Think hard</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-10T15:33:32.476Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Deng Xinliang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode#56. Merge Intervals</title>
    <link href="http://yoursite.com/2018/04/05/Merge-Intervals-56/"/>
    <id>http://yoursite.com/2018/04/05/Merge-Intervals-56/</id>
    <published>2018-04-05T05:07:27.000Z</published>
    <updated>2018-04-10T15:33:32.476Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-56-Merge-Intervals"><a href="#LeetCode-56-Merge-Intervals" class="headerlink" title="LeetCode#56 Merge Intervals"></a><a href="https://leetcode.com/problems/merge-intervals/description/" target="_blank" rel="noopener">LeetCode#56 Merge Intervals</a></h4><p>Given a collection of intervals, merge all overlapping intervals.</p><p>For example,<br>Given <code>[1,3],[2,6],[8,10],[15,18]</code>,<br>return <code>[1,6],[8,10],[15,18]</code>.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>题目的意思是合并交集。假设有集合组<code>[1,3],[2,6],[8,10],[15,18]</code>，如下图：<br><a id="more"></a><br><img src="1.png" alt="p1"></p><p>将这几个集合合并后如下：<br><img src="2.png" alt="p2"></p><p>从坐标轴中很容易可以得到灵感，那就是创建一个数组array，将数组中所有的值初始化为0，遍历所有的集合，将集合范围内的所有数作为下标，将这些下标对应的array的值置为1。最后遍历数组，将连续的1认为一个集合，将集合的边界输出即可。</p><p>但是仔细思考就会发现，虽然可以通过遍历集合找到最大值和最小值，以此确定数组的边界。但是由于题目没有规定集合的范围，得出的数组长度可能太大，会出现内存溢出，因此此方法行不通。</p><p>让我们将合并过程倒退一步：<br><img src="3.png" alt="p3"><br>将左右边界标出来，很容易就可以看出，对于每一个合并之后的集合，总是包含相同个数的左右边界。那么我们是不是可以通过记录左右边界，并从小到大遍历所有的边界，再使用一个整数<code>count</code>来计算左右边界出现的个数，出现左边界则<code>count + 1</code>，右边界则<code>count - 1</code>。这样的话，当<code>count = 0</code>的时候，就是遍历完了一个集合。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Struct Interval &#123;</span><br><span class="line">  start <span class="comment">// start is the left edge of this set</span></span><br><span class="line">  end   <span class="comment">// end is the right edge of this set</span></span><br><span class="line"></span><br><span class="line">  Interval(s, e)</span><br><span class="line">    start = s</span><br><span class="line">    end = e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Interval&gt; <span class="title">merge</span><span class="params">(intervals)</span>  <span class="comment">// intervals is a list of interval before merged</span></span></span><br><span class="line"><span class="function">  min </span>= Integer.MAX_VALUE</span><br><span class="line">  max = Integer.MIN_VALUE</span><br><span class="line">  </span><br><span class="line">  leftEdges = <span class="keyword">new</span> Map();   <span class="comment">// map的key是各个集合的左边界，value是左边界出现的次数</span></span><br><span class="line">  rightEdges = <span class="keyword">new</span> Map();  <span class="comment">// map的key是各个集合右边界，value是右边界出现的次数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (interval in intervals)</span><br><span class="line">    <span class="keyword">if</span> (interval.end &gt; max)</span><br><span class="line">      max = interval.end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interval.start &lt; min)</span><br><span class="line">      min = interval.start</span><br><span class="line"></span><br><span class="line">    leftEdges.put(interval.start, leftEdges.getOrDefault(interval.start, <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">    rightEdges.put(interval.end, rightEdges.getOrDefault(interval.end, <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  start = <span class="number">0</span></span><br><span class="line">  result = <span class="keyword">new</span> List;  <span class="comment">// List是保存合并后的Interval的集合</span></span><br><span class="line">  <span class="keyword">for</span> (i = min; i &lt; max; i++)</span><br><span class="line">    <span class="keyword">int</span> leftCount = leftEdges.getOrDefault(i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (leftCount &gt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">if</span> (count = <span class="number">0</span>)</span><br><span class="line">        start = i</span><br><span class="line">      count += leftCount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rightCount = rightEdges.getOrDefault(i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> (rightCount &gt; <span class="number">0</span>)</span><br><span class="line">      count -= rightCount</span><br><span class="line">      <span class="keyword">if</span> (count = <span class="number">0</span>)</span><br><span class="line">        result.add(<span class="keyword">new</span> Interval(start, i))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>由于以上使用了两个<code>map</code>，每访问一个<code>i</code>都要查询两个<code>map</code>，因此速度上会有些慢。既然是计算左右边界出现的次数相等，那么我们完全可以将结果计算出来并保存到一个<code>map</code>中。因为同一个数可能是一个集合的左边界的同时，也是另一个集合的右边界，因此当这个数是左边界时，就将<code>map</code>中对应值<code>+1</code>，否则就<code>-1</code>。最后按照上述代码遍历以<code>min</code>和<code>max</code>为边界，循环取出<code>map</code>中的值，并与<code>count</code>相加，当运算结果为<code>count = 0</code>，就可以输出一个合并后的集合。伪代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Interval&gt; <span class="title">merge</span><span class="params">(intervals)</span>  <span class="comment">// intervals is a list of interval before merged</span></span></span><br><span class="line"><span class="function">  min </span>= Integer.MAX_VALUE</span><br><span class="line">  max = Integer.MIN_VALUE</span><br><span class="line">  </span><br><span class="line">  edges = <span class="keyword">new</span> Map();   <span class="comment">// map的key是各个集合的边界，value是该边界出现的整合次数</span></span><br><span class="line">                       <span class="comment">// 即作为左边界出现的次数减去作为右边界出现的次数）</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (interval in intervals)</span><br><span class="line">    <span class="keyword">if</span> (interval.end &gt; max)</span><br><span class="line">      max = interval.end</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interval.start &lt; min)</span><br><span class="line">      min = interval.start</span><br><span class="line"></span><br><span class="line">    edges.put(interval.start, edges.getOrDefault(interval.start, <span class="number">0</span>) + <span class="number">1</span>)</span><br><span class="line">    edges.put(interval.end, edges.getOrDefault(interval.end, <span class="number">0</span>) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  start = <span class="number">0</span></span><br><span class="line">  result = <span class="keyword">new</span> List;  <span class="comment">// List是保存合并后的Interval的集合</span></span><br><span class="line">  <span class="keyword">for</span> (i = min; i &lt; max; i++)</span><br><span class="line">    <span class="comment">// 如果这个数不是任何边界，则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!edges.contains(i))</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = edges.getOrDefault(i, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 如果一个没有与其他任何集合有交集的集合的左右边界相同，</span></span><br><span class="line">    <span class="comment">// 那就直接将其添加到结果中</span></span><br><span class="line">    <span class="keyword">if</span> (c = <span class="number">0</span> &amp;&amp; count = <span class="number">0</span>)</span><br><span class="line">      list.add(<span class="keyword">new</span> Interval(i, i))</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count = <span class="number">0</span>)</span><br><span class="line">      start = i</span><br><span class="line">      count = c</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      count += c</span><br><span class="line">      <span class="keyword">if</span> (count = <span class="number">0</span>)  <span class="comment">// 结果为0，说明遇到了合并后的集合右边界</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Interval(start, i))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;LeetCode-56-Merge-Intervals&quot;&gt;&lt;a href=&quot;#LeetCode-56-Merge-Intervals&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#56 Merge Intervals&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-intervals/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode#56 Merge Intervals&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Given a collection of intervals, merge all overlapping intervals.&lt;/p&gt;
&lt;p&gt;For example,&lt;br&gt;Given &lt;code&gt;[1,3],[2,6],[8,10],[15,18]&lt;/code&gt;,&lt;br&gt;return &lt;code&gt;[1,6],[8,10],[15,18]&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h4&gt;&lt;p&gt;题目的意思是合并交集。假设有集合组&lt;code&gt;[1,3],[2,6],[8,10],[15,18]&lt;/code&gt;，如下图：&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="medium" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/medium/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode#268. Missing Number</title>
    <link href="http://yoursite.com/2018/04/04/Missing-Number-268/"/>
    <id>http://yoursite.com/2018/04/04/Missing-Number-268/</id>
    <published>2018-04-04T14:57:46.000Z</published>
    <updated>2018-04-04T15:16:28.444Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-268-Missing-Number"><a href="#LeetCode-268-Missing-Number" class="headerlink" title="LeetCode#268. Missing Number"></a><a href="https://leetcode.com/problems/missing-number/description/" target="_blank" rel="noopener">LeetCode#268. Missing Number</a></h4><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p><p><strong>Example 1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p><strong>Example 2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong><br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><a id="more"></a><p>参考之前分析的<a href="https://dxinl.github.io/2018/04/01/Single-Number-136/" target="_blank" rel="noopener">LeetCode#136</a>，修改数组元素是最简单直接的方法。</p><h5 id="修改数组解法"><a href="#修改数组解法" class="headerlink" title="修改数组解法"></a>修改数组解法</h5><p>由于数组中可能包含0，0的正负数都是0，因此不能使用取负数的方式来完成。但是因为数组总是<code>[0, array.length]</code>点真子集，那么我们只需要使访问过的数不在这个范围即可。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missing</span><span class="params">(nums)</span> <span class="comment">// nums is a integers array, and this function return the missing number</span></span></span><br><span class="line"><span class="function">  <span class="title">for</span> <span class="params">(n in nums)</span></span></span><br><span class="line"><span class="function">    n </span>= n &lt; <span class="number">0</span> ? (-n + <span class="number">1</span>) : n</span><br><span class="line">    <span class="keyword">if</span> (n &lt; nums.length)</span><br><span class="line">      nums[n] = -nums[n] - <span class="number">1</span>         <span class="comment">// 取负数并减1，避开0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++)  <span class="comment">// 找到唯一的非负数的下标，下标就是没有出现过的数</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums.length</span><br></pre></td></tr></table></figure></p><h5 id="异或解法"><a href="#异或解法" class="headerlink" title="异或解法"></a>异或解法</h5><p>那么，使用异或方法能不能解决这个问题呢？我们可以看到给定的数组中不会存在重复的数，但是数组总是<code>[0, array.length]</code>的真子集，而其补集只有一个数。那么，问题就很简单了，只要我们把数组和<code>[0, array.length]</code>做异或，就能找到唯一的那个数了。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missing</span><span class="params">(nums)</span> <span class="comment">// nums is a integers array, and this function return the missing number</span></span></span><br><span class="line"><span class="function">  <span class="keyword">int</span> result </span>= nums.length</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    result ^= i</span><br><span class="line">    result ^= nums[i]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums.length</span><br></pre></td></tr></table></figure></p><p>通过这道题以及<a href="https://dxinl.github.io/2018/04/01/Single-Number-136/" target="_blank" rel="noopener">LeetCode#136</a>，可以发现在适当的情境下，使用位运算总是能简洁、优雅地解决问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;LeetCode-268-Missing-Number&quot;&gt;&lt;a href=&quot;#LeetCode-268-Missing-Number&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#268. Missing Number&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/missing-number/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode#268. Missing Number&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [3,0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 2&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [9,6,4,2,3,5,7,0,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode#387. First Unique Character in a String</title>
    <link href="http://yoursite.com/2018/04/04/First-Unique-Char-In-String-387/"/>
    <id>http://yoursite.com/2018/04/04/First-Unique-Char-In-String-387/</id>
    <published>2018-04-04T14:13:46.000Z</published>
    <updated>2018-04-04T14:51:30.570Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-387-First-Unique-Character-in-a-String"><a href="#LeetCode-387-First-Unique-Character-in-a-String" class="headerlink" title="LeetCode#387. First Unique Character in a String"></a><a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/" target="_blank" rel="noopener">LeetCode#387. First Unique Character in a String</a></h4><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><p><strong>Examples:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure></p><p><strong>Note:</strong> You may assume the string contain only lowercase letters.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>通过之前的练习<a href="https://dxinl.github.io/2018/04/03/Valid-Anagram-242/" target="_blank" rel="noopener">LeetCode#242</a>，很容易就能想到使用数组来记录字母出现的次数，然后找到字符串中，第一个出现次数为1的字符。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unique</span><span class="params">(s)</span>  <span class="comment">// s is the target string</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(s = <span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">    return -1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  count </span>= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]</span><br><span class="line">  chars = s.toCharArray()</span><br><span class="line">  <span class="keyword">for</span> (c in chars)</span><br><span class="line">    count[c - <span class="string">'a'</span>]++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">    <span class="keyword">if</span> (count[chars[i] - <span class="string">'a'</span>]-- = <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>上述答案还可以通过消除减法来降低耗时。因为题目规定字符串中只包含小写字母，因此可以不考虑<em><a href="https://www.asciitable.com/" target="_blank" rel="noopener">扩展ASCII码</a></em>，也就是创建一个长度为<code>128</code>的数组，从而避免减法。</p><h4 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h4><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unique</span><span class="params">(s)</span>   <span class="comment">// s is the target string</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(s = <span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">    return -1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  chars </span>= s.toCharArray()</span><br><span class="line">  <span class="keyword">int</span> out = chars.length</span><br><span class="line">  <span class="keyword">for</span> (c = <span class="string">'a'</span> to <span class="string">'z'</span>)   <span class="comment">// c is a char variable</span></span><br><span class="line">    index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">      <span class="keyword">if</span> (chars[i] = c)</span><br><span class="line">        index = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index = -<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    lastIndex = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i = (chars.length - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (chars[i] = c)</span><br><span class="line">        lastIndex = i</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index = lastIndex)</span><br><span class="line">      out = min(index, out)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> out == chars.length ? -<span class="number">1</span> : out</span><br></pre></td></tr></table></figure><p>这种解法是通过找到每个字母第一次出现的位置和最后一次出现的位置，并将这两个位置进行对比，如果一样就说明只出现了一次。在LeetCode的这道题中，这种解法的速度会更快。不过在极端情况下，这种解法速度会降低到<code>26 * s.length()</code>，而第一种解法永远只需要<code>2 * s.length()</code>次。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;LeetCode-387-First-Unique-Character-in-a-String&quot;&gt;&lt;a href=&quot;#LeetCode-387-First-Unique-Character-in-a-String&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#387. First Unique Character in a String&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/first-unique-character-in-a-string/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode#387. First Unique Character in a String&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s = &amp;quot;leetcode&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return 0.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &amp;quot;loveleetcode&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return 2.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You may assume the string contain only lowercase letters.&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h4&gt;&lt;p&gt;通过之前的练习&lt;a href=&quot;https://dxinl.github.io/2018/04/03/Valid-Anagram-242/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode#242&lt;/a&gt;，很容易就能想到使用数组来记录字母出现的次数，然后找到字符串中，第一个出现次数为1的字符。如下：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;unique&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s)&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// s is the target string&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;  &lt;span class=&quot;title&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(s = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    return -1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;  count &lt;/span&gt;= &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  chars = s.toCharArray()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (c in chars)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    count[c - &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;]++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; chars.length; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (count[chars[i] - &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;]-- = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述答案还可以通过消除减法来降低耗时。因为题目规定字符串中只包含小写字母，因此可以不考虑&lt;em&gt;&lt;a href=&quot;https://www.asciitable.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;扩展ASCII码&lt;/a&gt;&lt;/em&gt;，也就是创建一个长度为&lt;code&gt;128&lt;/code&gt;的数组，从而避免减法。&lt;/p&gt;
&lt;h4 id=&quot;另一种解法&quot;&gt;&lt;a href=&quot;#另一种解法&quot; class=&quot;headerlink&quot; title=&quot;另一种解法&quot;&gt;&lt;/a&gt;另一种解法&lt;/h4&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="easy" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/easy/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode#242. Valid Anagram</title>
    <link href="http://yoursite.com/2018/04/03/Valid-Anagram-242/"/>
    <id>http://yoursite.com/2018/04/03/Valid-Anagram-242/</id>
    <published>2018-04-03T14:00:40.000Z</published>
    <updated>2018-04-04T14:22:53.403Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-242-Valid-Anagram"><a href="#LeetCode-242-Valid-Anagram" class="headerlink" title="LeetCode#242 Valid Anagram"></a><a href="https://leetcode.com/problems/valid-anagram/description/" target="_blank" rel="noopener">LeetCode#242 Valid Anagram</a></h4><p>Given two strings s and t, write a function to determine if t is an anagram of s.</p><p>For example,<br>s = “anagram”, t = “nagaram”, return true.<br>s = “rat”, t = “car”, return false.</p><p><strong>Note:</strong><br>You may assume the string contains only lowercase alphabets.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>既然只有小写字母，那就可以通过一个长度为26的数组记录第一个字符串中的字符出现的次数，再通过遍历第二个字符串并做减法，如果某个字符对应的次数小于0，则说明两个字符串不是变位词。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(s1, s2)</span></span></span><br><span class="line"><span class="function">  count </span>= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>]</span><br><span class="line">  chars1 = s1.toCharArray()</span><br><span class="line">  <span class="keyword">for</span> (c in chars1)</span><br><span class="line">    count[c - <span class="string">'a'</span>]++</span><br><span class="line"></span><br><span class="line">  chars2 = s2.toCharArray()</span><br><span class="line">  <span class="keyword">for</span> (c in chars2)</span><br><span class="line">    <span class="keyword">if</span> (count[c - <span class="string">'a'</span>]-- == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode-242-Valid-Anagram&quot;&gt;&lt;a href=&quot;#LeetCode-242-Valid-Anagram&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#242 Valid Anagram&quot;&gt;&lt;/a&gt;&lt;a href=
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="easy" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/easy/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode#169. Majority Element</title>
    <link href="http://yoursite.com/2018/04/03/Majority-Element-169/"/>
    <id>http://yoursite.com/2018/04/03/Majority-Element-169/</id>
    <published>2018-04-03T13:24:42.000Z</published>
    <updated>2018-04-03T13:48:12.863Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-169-Majority-Element"><a href="#LeetCode-169-Majority-Element" class="headerlink" title="LeetCode#169 Majority Element"></a><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">LeetCode#169 Majority Element</a></h4><p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>[n/2]</code> times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这道题很简单，可以先排序，中间的数就是答案。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majority</span><span class="params">(nums)</span>  <span class="comment">// nums is a integer array</span></span></span><br><span class="line"><span class="function">  <span class="title">sort</span><span class="params">(nums)</span></span></span><br><span class="line"><span class="function">  return nums[nums.length / 2]</span></span><br></pre></td></tr></table></figure></p><h4 id="只有想不到"><a href="#只有想不到" class="headerlink" title="只有想不到"></a>只有想不到</h4><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majority</span><span class="params">(nums)</span></span></span><br><span class="line"><span class="function">  target </span>= <span class="number">0</span>;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (n in nums)</span><br><span class="line">    <span class="keyword">if</span> (count = <span class="number">0</span>)</span><br><span class="line">      target = n</span><br><span class="line">      count++</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (target = n)</span><br><span class="line">      count++</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      count--</span><br><span class="line">  <span class="keyword">return</span> target</span><br></pre></td></tr></table></figure><p>如果我们用一个数字<code>count</code>记录一个数<code>target</code>出现的次数，如果下一个数还是这个数就将<code>count</code>加<code>1</code>，否则减<code>1</code>。如果<code>count</code>为<code>0</code>，就以下一个数为<code>target</code>并重新开始计算<code>count</code>。最后输出<code>target</code>。因为目标数字出现次数超过一半，其他数字的<code>count</code>最后肯定会减至<code>0</code>。那么循环结束后的<code>target</code>就是答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;LeetCode-169-Majority-Element&quot;&gt;&lt;a href=&quot;#LeetCode-169-Majority-Element&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#169 Majority Element&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/majority-element/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode#169 Majority Element&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than &lt;code&gt;[n/2]&lt;/code&gt; times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
&lt;h4 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h4&gt;&lt;p&gt;这道题很简单，可以先排序，中间的数就是答案。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;majority&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// nums is a integer array&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;  &lt;span class=&quot;title&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(nums)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;  return nums[nums.length / 2]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;只有想不到&quot;&gt;&lt;a href=&quot;#只有想不到&quot; class=&quot;headerlink&quot; title=&quot;只有想不到&quot;&gt;&lt;/a&gt;只有想不到&lt;/h4&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="easy" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/easy/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode#371. Sum of Two Integers</title>
    <link href="http://yoursite.com/2018/04/03/Sum-of-Two-Integers-371/"/>
    <id>http://yoursite.com/2018/04/03/Sum-of-Two-Integers-371/</id>
    <published>2018-04-03T11:34:10.000Z</published>
    <updated>2018-04-03T13:28:24.459Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-371-Sum-of-Two-Integers"><a href="#LeetCode-371-Sum-of-Two-Integers" class="headerlink" title="LeetCode#371 Sum of Two Integers"></a><a href="https://leetcode.com/problems/sum-of-two-integers/description/" target="_blank" rel="noopener">LeetCode#371 Sum of Two Integers</a></h4><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator <code>+</code> and <code>-</code>.</p><p>Example:<br>Given _a_ = 1 and _b_ = 2, return 3.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>按照题目的要求，不能使用<code>+</code>和<code>-</code>，那只能使用位运算了。这样的话，很容易就能想到使用<code>&amp;</code>来进行计算，通过计算两个数每一位的与，以及下一位与的结果，就可以知道当前位的值。但是由于不能用<code>+</code>，所以即使计算出了结果的每一位，也没办法计算出最后的值。</p><p>既然<code>&amp;</code>可以计算出进位，那么是否有其他的位运算可以计算出当前位的值？那就是<code>^</code>了。通过异或计算出的值是不含进位的，因此在异或之后需要和进位结果再异或一次，以得出新的值。但是这次计算又可能产生新的进位，因此需要循环直到不再含有进位。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(a, b)</span></span></span><br><span class="line"><span class="function">  <span class="title">while</span> <span class="params">(b != <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">  carry </span>= a &amp; b    <span class="comment">// 计算出需要进位的位</span></span><br><span class="line">  a = a ^ b</span><br><span class="line">  b = carry &lt;&lt; <span class="number">1</span>   <span class="comment">// 左移一位即可得出进位结果</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode-371-Sum-of-Two-Integers&quot;&gt;&lt;a href=&quot;#LeetCode-371-Sum-of-Two-Integers&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#371 Sum of Two Inte
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="easy" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/easy/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode#104. Maximum Depth of Binary Tree</title>
    <link href="http://yoursite.com/2018/04/01/Max-Depth-Of-BT-104/"/>
    <id>http://yoursite.com/2018/04/01/Max-Depth-Of-BT-104/</id>
    <published>2018-04-01T13:33:50.000Z</published>
    <updated>2018-04-03T11:34:15.743Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-104-Maximum-Depth-of-Binary-Tree"><a href="#LeetCode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode#104 Maximum Depth of Binary Tree"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">LeetCode#104 Maximum Depth of Binary Tree</a></h4><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这是一道典型的二叉树遍历题目，可以查看之前对于<a href="https://dxinl.github.io/2018/03/31/Tree-traversal/" target="_blank" rel="noopener">“树的遍历”的介绍</a>。可以选择深度优先搜索递归法解决：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(node)</span></span></span><br><span class="line"><span class="function">  return <span class="title">depth</span><span class="params">(node, <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(node, depth)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(node = <span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">    return depth</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  depth++</span></span><br><span class="line"><span class="function">  return <span class="title">max</span><span class="params">(depth(node.left, depth)</span>, <span class="title">depth</span><span class="params">(node.right, depth)</span>)</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;LeetCode-104-Maximum-Depth-of-Binary-Tree&quot;&gt;&lt;a href=&quot;#LeetCode-104-Maximum-Depth-of-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;LeetCode#1
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="easy" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/easy/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode#136. Single Number</title>
    <link href="http://yoursite.com/2018/04/01/Single-Number-136/"/>
    <id>http://yoursite.com/2018/04/01/Single-Number-136/</id>
    <published>2018-04-01T06:58:17.000Z</published>
    <updated>2018-04-04T14:56:06.066Z</updated>
    
    <content type="html"><![CDATA[<h4 id="LeetCode-136-Single-Number"><a href="#LeetCode-136-Single-Number" class="headerlink" title="LeetCode #136 Single Number"></a><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener">LeetCode #136 Single Number</a></h4><p>Given an array of integers, every element appears twice except for one. Find that single one.</p><p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><a id="more"></a><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>最容易想到的解法是利用<code>HashMap</code>，以数组中的数为<code>key</code>，以出现次数为<code>value</code>统计每一个整数出现的次数，然后遍历<code>HashMap</code>，取出出现次数为1的数。这样的话，线性时间就可以找出只出现一次的数字。</p><p>但是题目不仅要求线性时间，还问能不能使用额外的内存。分析一下题目，除了一个整数之外，其他每个整数都是成对出现的。利用计数的方法可以得出每个数字出现的次数，但是这必须要额外的空间。不需要额外空间的方式有两种，一种是修改数组中的元素，以突出唯一的元素；而另一个则是通过运算，使最后的结果等于唯一的数。</p><h5 id="修改数组元素"><a href="#修改数组元素" class="headerlink" title="修改数组元素"></a>修改数组元素</h5><p>要使用这种方法，必须保证不影响遍历的结果，因此这种方法只适用于很少一部分前提条件满足的情况。</p><p>如果这些数字都在[1, (nums.length + 1) / 2]中，我们可以通过对数字对应下标的数字取反的方式来得到只出现一次的数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSingle</span><span class="params">(arary)</span>      <span class="comment">// array is the array of integers</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(array.length = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    return -1</span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(array.length = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    return array[0]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">// 翻转下标为[n-1]的数字</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 如果[n]出现了两次，那么[n-1]对应的数字最后一定是正数</span></span></span><br><span class="line"><span class="function">  <span class="comment">// 而如果只出现了一次，则为负数</span></span></span><br><span class="line"><span class="function">  <span class="title">for</span> <span class="params">(n in array)</span></span></span><br><span class="line"><span class="function">    tmp </span>= array[n - <span class="number">1</span>]</span><br><span class="line">    tmp = tmp &lt; <span class="number">0</span> ? -tmp : tmp;</span><br><span class="line">    array[tmp - <span class="number">1</span>] = -array[tmp - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到唯一的一个负数，其下标+1即为唯一出现一次的整数</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, size = (arary.length + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">    <span class="keyword">if</span> (array[i] &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>但是这种方案显然只适合于这种数组内元素都是从1到((array.length + 1) / 2)的连续正整数。</p><h5 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h5><p>我们需要找到一种运算最后能够得出唯一出现一次的数。四则运算显然不能满足要求，那么位运算呢？与？或？异或？异或？没错，两个相等的数异或为0，0与一个数异或可以得到该数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSingle</span><span class="params">(array)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(array.length = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    return -1</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  result </span>= <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (n in array)</span><br><span class="line">    result ^= n</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></p><p>简洁而优雅。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;LeetCode-136-Single-Number&quot;&gt;&lt;a href=&quot;#LeetCode-136-Single-Number&quot; class=&quot;headerlink&quot; title=&quot;LeetCode #136 Single Number&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LeetCode #136 Single Number&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Given an array of integers, every element appears twice except for one. Find that single one.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="easy" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/easy/"/>
    
    
  </entry>
  
  <entry>
    <title>树的遍历</title>
    <link href="http://yoursite.com/2018/03/31/Tree-traversal/"/>
    <id>http://yoursite.com/2018/03/31/Tree-traversal/</id>
    <published>2018-03-31T01:49:51.000Z</published>
    <updated>2018-03-31T15:37:47.583Z</updated>
    
    <content type="html"><![CDATA[<p>树的遍历也被称之为树的搜索。分为深度优先搜索和广度优先搜索。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>深度优先搜索是指尽可能远地遍历每一条分支直到分支结束，再通过回溯遍历另一条分支。按照访问节点及其左右子树的顺序可以将其实现细分为三种：先序遍历、中序遍历、后续遍历。</p><a id="more"></a><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ol><li>打印当前节点</li><li>使用先序遍历遍历及打印左子树</li><li>使用先序遍历遍历及打印右子树</li></ol><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preorder(node)</span><br><span class="line">  <span class="keyword">if</span> (node = <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  visit(node)</span><br><span class="line">  preorder(node.left)</span><br><span class="line">  preorder(node.right)</span><br></pre></td></tr></table></figure><h5 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">preorder(node)</span><br><span class="line">  <span class="keyword">if</span> (node = <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  s ← empty stack</span><br><span class="line">  s.push(node)</span><br><span class="line">  <span class="keyword">while</span> (!s.isEmpty())</span><br><span class="line">    node ← s.pop()</span><br><span class="line">    visit(node)</span><br><span class="line">    <span class="comment">// push right child first so that the left subtree will be traversed first</span></span><br><span class="line">    <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">      s.push(node.right)</span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">      s.push(node.left)</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ol><li>使用中序遍历遍历及打印左子树</li><li>打印当前节点</li><li>使用中序遍历遍历及打印右子树</li></ol><h5 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inorder(node)</span><br><span class="line">  <span class="keyword">if</span> (node = <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  inorder(node.left)</span><br><span class="line">  visit(node)</span><br><span class="line">  inorder(node.right)</span><br></pre></td></tr></table></figure><h5 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inorder(node)</span><br><span class="line">  <span class="keyword">if</span> (node = <span class="keyword">null</span>) </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  s ← empty stack</span><br><span class="line">  <span class="keyword">while</span> (!s.isEmpty() || node != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">      s.push(node)</span><br><span class="line">      node ← node.left</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      node = s.pop()</span><br><span class="line">      visit(node)</span><br><span class="line">      node ← node.right</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ol><li>使用后序遍历遍历及打印左子树</li><li>使用后序遍历遍历及打印右子树</li><li>打印当前节点</li></ol><h5 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postorder(node)</span><br><span class="line">  <span class="keyword">if</span> (node = <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  postorder(node.left)</span><br><span class="line">  postorder(node.right)</span><br><span class="line">  visit(node)</span><br></pre></td></tr></table></figure><h5 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">postorder(node)</span><br><span class="line">  <span class="keyword">if</span> (node = <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  s ← empty stack</span><br><span class="line">  lastVisitedNode ← <span class="keyword">null</span></span><br><span class="line">  <span class="keyword">while</span> (!s.isEmpty() || node != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">      s.push(node)</span><br><span class="line">      node ← node.left</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="comment">// do not pop it immediately</span></span><br><span class="line">      peek ← s.peek()</span><br><span class="line">      <span class="comment">// if the right subtree exists and has not been traversed,</span></span><br><span class="line">      <span class="comment">// then traverse it; else display current node.</span></span><br><span class="line">      <span class="keyword">if</span> (peek.right != <span class="keyword">null</span> &amp;&amp; peek != lastVisitedNode)</span><br><span class="line">        node ← peek.right</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        lastVisitedNode ← s.pop();</span><br><span class="line">        visit(lastVisitedNode)</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索是自根节点起依次遍历每层的节点的方法。伪代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bfs(node)</span><br><span class="line">  <span class="keyword">if</span> (node = <span class="keyword">null</span>) </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  q ← empty queue</span><br><span class="line">  q.enqueue(node)</span><br><span class="line">  <span class="keyword">while</span> (!node.isEmpty())</span><br><span class="line">    n ← q.dequeue()</span><br><span class="line">    visit(n)</span><br><span class="line">    <span class="keyword">if</span> (n.left != <span class="keyword">null</span>)</span><br><span class="line">      q.enqueue(n.left)</span><br><span class="line">    <span class="keyword">if</span> (n.right != <span class="keyword">null</span>)</span><br><span class="line">      q.enqueue(n.right)</span><br></pre></td></tr></table></figure></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://en.wikipedia.org/wiki/Tree_traversal" target="_blank" rel="noopener">Tree traversal</a><br><a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">DFS</a><br><a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank" rel="noopener">BFS</a><br><a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29" target="_blank" rel="noopener">LIFO</a><br><a href="https://en.wikipedia.org/wiki/FIFO_%28computing_and_electronics%29" target="_blank" rel="noopener">FIFO</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树的遍历也被称之为树的搜索。分为深度优先搜索和广度优先搜索。&lt;/p&gt;
&lt;h3 id=&quot;深度优先搜索&quot;&gt;&lt;a href=&quot;#深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;深度优先搜索&quot;&gt;&lt;/a&gt;深度优先搜索&lt;/h3&gt;&lt;p&gt;深度优先搜索是指尽可能远地遍历每一条分支直到分支结束，再通过回溯遍历另一条分支。按照访问节点及其左右子树的顺序可以将其实现细分为三种：先序遍历、中序遍历、后续遍历。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="树" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E6%A0%91/"/>
    
    
  </entry>
  
  <entry>
    <title>LeakCanary 解析</title>
    <link href="http://yoursite.com/2018/03/29/LeakCanary/"/>
    <id>http://yoursite.com/2018/03/29/LeakCanary/</id>
    <published>2018-03-29T02:57:25.000Z</published>
    <updated>2018-03-30T15:04:30.697Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>“A small leak will sink a great ship.”</em></strong> - Benjamin Franklin</p><p>【目录】</p><ul><li><a href="#离线配置">离线配置</a><ul><li><a href="#下载离线aar包及依赖文件">下载离线aar包及依赖文件</a></li><li><a href="#加入项目中">加入项目中</a></li><li><a href="#编辑gradle文件">编辑gradle文件</a></li></ul></li><li><a href="#源码分析">源码分析</a><ul><li><a href="#判断是否泄露">判断是否泄露</a></li><li><a href="#查找最短强引用路径">查找最短强引用路径</a></li></ul></li><li><a href="#附录">附录</a></li></ul><a id="more"></a><h2 id="离线配置"><a href="#离线配置" class="headerlink" title="离线配置"></a>离线配置</h2><blockquote><p>在线配置根据<a href="https://github.com/square/leakcanary/blob/master/README.md" target="_blank" rel="noopener">LeakCanary Github</a>上的指引即可完成。不过因为公司一些网络上的限制，我只能使用离线配置来引入LeakCanary。</p></blockquote><h3 id="下载离线aar包及依赖文件"><a href="#下载离线aar包及依赖文件" class="headerlink" title="下载离线aar包及依赖文件"></a>下载离线aar包及依赖文件</h3><p>首先从Maven上下载LeakCanary的aar包以及依赖的jar包，共有以下五个文件：</p><ul><li><a href="http://mvnrepository.com/artifact/com.squareup.leakcanary/leakcanary-android" target="_blank" rel="noopener">leakcanary-android.aar</a></li><li><a href="http://mvnrepository.com/artifact/com.squareup.leakcanary/leakcanary-watcher" target="_blank" rel="noopener">leakcanary-watcher.jar</a></li><li><a href="http://mvnrepository.com/artifact/com.squareup.leakcanary/leakcanary-analyzer" target="_blank" rel="noopener">leakcanary-analyzer.jar</a></li><li><a href="http://mvnrepository.com/artifact/com.squareup.leakcanary/leakcanary-android-no-op" target="_blank" rel="noopener">leakcanary-android-no-op.aar</a></li><li><a href="http://mvnrepository.com/artifact/com.squareup.haha/haha" target="_blank" rel="noopener">haha.jar</a></li></ul><h3 id="加入项目中"><a href="#加入项目中" class="headerlink" title="加入项目中"></a>加入项目中</h3><p>在工程中建立一个目录，可以跟<code>src</code>、<code>res</code>等目录同级，比如<code>YourProject/leakcanary/</code>，然后将上述五个文件放到此目录下。</p><h3 id="编辑gradle文件"><a href="#编辑gradle文件" class="headerlink" title="编辑gradle文件"></a>编辑gradle文件</h3><p>在Module的<code>build.gradle</code>中加入以下代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">  <span class="keyword">flatDir</span> &#123;</span><br><span class="line">    <span class="comment">// 这个路径就是上一步中建立的文件夹的相对路径</span></span><br><span class="line">    dirs <span class="string">'leakcanary'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  debugCompile <span class="keyword">fileTree</span>(dir: <span class="string">'leakcanary'</span>, <span class="keyword">include</span>: <span class="string">'*.jar'</span>)</span><br><span class="line">  <span class="comment">// 以下两句的name是指文件名，具体名称视你的文件名而定。</span></span><br><span class="line">  debugCompile (name: <span class="string">'com.squareup.leakcanary-android'</span>, ext: <span class="string">'aar'</span>)</span><br><span class="line">  releaseCompile (name: <span class="string">'com.squareup.leakcanary-android-no-op'</span>, ext: <span class="string">'aar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><blockquote><p>对 LeakCanary 的源码进行分析。</p></blockquote><h3 id="判断是否泄露"><a href="#判断是否泄露" class="headerlink" title="判断是否泄露"></a>判断是否泄露</h3><p>先上一张时序图：</p><p><img src="%E7%9B%91%E8%A7%86%E6%97%B6%E5%BA%8F%E5%9B%BE.jpg" alt="SequenceDiagram"><br>其关键代码片段如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** RefWatcher.java */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当我们要监视一个对象是否存在泄露时，会调用这个方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference)</span> </span>&#123;</span><br><span class="line">  watch(watchedReference, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 随机生成一个key，保证key的唯一性</span></span><br><span class="line">  String key = UUID.randomUUID().toString();</span><br><span class="line">  <span class="comment">// 将key保存在 Set 中</span></span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  <span class="comment">// 创建WeakReference，key是联系 reference 对象和 retainedKeys 的纽带</span></span><br><span class="line">  <span class="keyword">final</span> KeyedWeakReference reference =</span><br><span class="line">      <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步判断对象是否存在泄露</span></span><br><span class="line">  ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 异步方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureGoneAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime, <span class="keyword">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  watchExecutor.execute(<span class="keyword">new</span> Retryable() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> Retryable.<span class="function">Result <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 检查是否存在泄漏 */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"ReferenceEquality"</span>) <span class="comment">// Explicitly checking for named null.</span></span><br><span class="line">Retryable.<span class="function">Result <span class="title">ensureGone</span><span class="params">(<span class="keyword">final</span> KeyedWeakReference reference, <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 首先将已回收的对象对应的key从retainedKeys中移除</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果正在debug断点调试，则延迟执行检查（因为断点会影响准确性）</span></span><br><span class="line">  <span class="keyword">if</span> (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">    <span class="comment">// The debugger can create false leaks.</span></span><br><span class="line">    <span class="keyword">return</span> RETRY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过判断retainedKeys中是否还包含当前的key来判断当前对象是否被回收，</span></span><br><span class="line">  <span class="comment">// 如果已被回收，则返回DONE</span></span><br><span class="line">  <span class="keyword">if</span> (gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DONE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有被回收，则触发一次GC</span></span><br><span class="line">  gcTrigger.runGc();</span><br><span class="line">  <span class="comment">// 再次将已回收的对象对应的key从retainedKeys中移除</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line">  <span class="comment">// 再次判断是否被回收</span></span><br><span class="line">  <span class="comment">// 如果被回收则返回DONE，结束</span></span><br><span class="line">  <span class="comment">// 如果没有被回收，则需要查找造成泄漏的引用链中最短的一条（一个对象可能被多个对象引用，所以造成泄漏的地方可能不止一处）</span></span><br><span class="line">  <span class="keyword">if</span> (!gone(reference)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取堆内存镜像文件，最终调用的是Debug#dumpHprofData(String)方法来获取内存镜像</span></span><br><span class="line">    File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">      <span class="comment">// Could not dump the heap.</span></span><br><span class="line">      <span class="keyword">return</span> RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line">    <span class="comment">// 启动分析服务</span></span><br><span class="line">    heapdumpListener.analyze(</span><br><span class="line">        <span class="keyword">new</span> HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,</span><br><span class="line">            gcDurationMs, heapDumpDurationMs));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gone</span><span class="params">(KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !retainedKeys.contains(reference.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWeaklyReachableReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  KeyedWeakReference ref;</span><br><span class="line">  <span class="keyword">while</span> ((ref = (KeyedWeakReference) queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    retainedKeys.remove(ref.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查找最短强引用路径"><a href="#查找最短强引用路径" class="headerlink" title="查找最短强引用路径"></a>查找最短强引用路径</h3><p>查找最短强引用路径的流程如下图：<br><img src="%E6%9C%80%E7%9F%AD%E5%BC%95%E7%94%A8%E9%93%BE%E6%9F%A5%E6%89%BE.png" alt="Shortest Strong Reference Path"></p><p>首先来看一下分析服务是如何启动的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** RefWatcher#ensureGone(KeyedWeakReference, long) */</span></span><br><span class="line"><span class="comment">// 启动分析服务</span></span><br><span class="line">heapdumpListener.analyze(</span><br><span class="line">    <span class="keyword">new</span> HeapDump(heapDumpFile, reference.key, reference.name, excludedRefs, watchDurationMs,</span><br><span class="line">        gcDurationMs, heapDumpDurationMs));</span><br></pre></td></tr></table></figure></p><p>上述代码执行后，会调用<code>ServiceHeapDumpListener#analyze(HeapDump)</code>，继而调用<code>HeapAnalyzerService#runAnalysis(Context, HeapDump, Class&lt;? extends AbstractAnalysisResultService&gt;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAnalysis</span><span class="params">(Context context, HeapDump heapDump,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(context, HeapAnalyzerService.class);</span><br><span class="line">  intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());</span><br><span class="line">  intent.putExtra(HEAPDUMP_EXTRA, heapDump);</span><br><span class="line">  context.startService(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HeapAnalyzerService</code>是一个<code>IntentService</code>，来看一下它的<code>onHandleIntent</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建HeapAnalyzer</span></span><br><span class="line">  HeapAnalyzer heapAnalyzer = <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用HeapAnalyzer分析内存泄露路径</span></span><br><span class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey);</span><br><span class="line">  <span class="comment">// 发送结果</span></span><br><span class="line">  AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>HeapAnalyzer#checkForLeak(File, String)</code>是查找最短强引用路径的开端。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用上文提到的使用UUID.randomUUID()方法生成的key来获取到泄露的对象实例，然后</span></span><br><span class="line"><span class="comment"> * 计算从该实例到达GC Roots的最短强引用路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnalysisResult <span class="title">checkForLeak</span><span class="params">(File heapDumpFile, String referenceKey)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    HprofBuffer buffer = <span class="keyword">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class="line">    HprofParser parser = <span class="keyword">new</span> HprofParser(buffer);</span><br><span class="line">    Snapshot snapshot = parser.parse();</span><br><span class="line">    <span class="comment">// 从内存镜像中获取所有的GC Roots，并将它们添加到一个集合中</span></span><br><span class="line">    deduplicateGcRoots(snapshot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射，通过key找到泄露的对象实例</span></span><br><span class="line">    Instance leakingRef = findLeakingReference(referenceKey, snapshot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// False alarm, weak reference was cleared in between key check and heap dump.</span></span><br><span class="line">    <span class="keyword">if</span> (leakingRef == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> noLeak(since(analysisStartNanoTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找泄露路径</span></span><br><span class="line">    <span class="keyword">return</span> findLeakTrace(analysisStartNanoTime, snapshot, leakingRef);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">return</span> failure(e, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AnalysisResult <span class="title">findLeakTrace</span><span class="params">(<span class="keyword">long</span> analysisStartNanoTime, Snapshot snapshot, Instance leakingRef)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ShortestPathFinder类是查找最短强引用路径的核心</span></span><br><span class="line">  ShortestPathFinder pathFinder = <span class="keyword">new</span> ShortestPathFinder(excludedRefs);</span><br><span class="line">  ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据查找的结果，建立泄露路径</span></span><br><span class="line">  LeakTrace leakTrace = buildLeakTrace(result.leakingNode);</span><br><span class="line"></span><br><span class="line">  String className = leakingRef.getClassObj().getClassName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Side effect: computes retained size.</span></span><br><span class="line">  snapshot.computeDominators();</span><br><span class="line"></span><br><span class="line">  Instance leakingInstance = result.leakingNode.instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> retainedSize = leakingInstance.getTotalRetainedSize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> check O sources and see what happened to android.graphics.Bitmap.mBuffer</span></span><br><span class="line">  <span class="keyword">if</span> (SDK_INT &lt;= N_MR1) &#123;</span><br><span class="line">    retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,</span><br><span class="line">      since(analysisStartNanoTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>ShortestPathFinder#findPath(Snapshot, Instance)</code>查找最短强引用路径</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">findPath</span><span class="params">(Snapshot snapshot, Instance leakingRef)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 将上面找到的所有GC Roots添加到队列中</span></span><br><span class="line">  enqueueGcRoots(snapshot);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  LeakNode leakingNode = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 如果将从GC Root开始的所有引用看做树，则这里就可以理解成使用广度优先搜索遍历引用“森林”</span></span><br><span class="line">  <span class="comment">// 如果将所有的引用都看做是长度为1的Edge，那么这些引用就组成了一幅有向图，</span></span><br><span class="line">  <span class="comment">// 这里就是使用类似Dijkstra算法的方法来寻找最短路径，越在队列后面的，距离GC Roots越远</span></span><br><span class="line">  <span class="keyword">while</span> (!toVisitQueue.isEmpty() || !toVisitIfNoPathQueue.isEmpty()) &#123;</span><br><span class="line">    LeakNode node;</span><br><span class="line">    <span class="comment">// 如果toVisitQueue中没有元素，则取toVisitIfNoPathQueue中的元素</span></span><br><span class="line">    <span class="comment">// 意思就是，如果遍历完了toVisitQueue还没有找到泄露的路径，那么就继续遍历设置了“例外”的那些对象</span></span><br><span class="line">    <span class="comment">// “例外”是什么情况？在后续两个方法会讲到。</span></span><br><span class="line">    <span class="keyword">if</span> (!toVisitQueue.isEmpty()) &#123;</span><br><span class="line">      node = toVisitQueue.poll();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node = toVisitIfNoPathQueue.poll();</span><br><span class="line">      <span class="keyword">if</span> (node.exclusion == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Expected node to have an exclusion "</span> + node);</span><br><span class="line">      &#125;</span><br><span class="line">      excludingKnownLeaks = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Termination</span></span><br><span class="line">    <span class="keyword">if</span> (node.instance == leakingRef) &#123;</span><br><span class="line">      leakingNode = node;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为一个对象可以被多个对象引用，以GC Root为根的引用树</span></span><br><span class="line">    <span class="comment">// 并不是严格意义上的树，所以如果已经遍历过当前对象，就跳过</span></span><br><span class="line">    <span class="keyword">if</span> (checkSeen(node)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是根据当前引用节点的类型，分别找到它们所引用的对象</span></span><br><span class="line">    <span class="keyword">if</span> (node.instance <span class="keyword">instanceof</span> RootObj) &#123;</span><br><span class="line">      visitRootObj(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.instance <span class="keyword">instanceof</span> ClassObj) &#123;</span><br><span class="line">      visitClassObj(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.instance <span class="keyword">instanceof</span> ClassInstance) &#123;</span><br><span class="line">      visitClassInstance(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.instance <span class="keyword">instanceof</span> ArrayInstance) &#123;</span><br><span class="line">      visitArrayInstance(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected type for "</span> + node.instance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回查找结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Result(leakingNode, excludingKnownLeaks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以类对象为例，会找到当前实例的所有对象成员，将它们添加到队列中。</span></span><br><span class="line"><span class="comment"> * 至于其他对象的遍历，大家感兴趣的话可以自行研究。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">visitClassInstance</span><span class="params">(LeakNode node)</span> </span>&#123;</span><br><span class="line">  ClassInstance classInstance = (ClassInstance) node.instance;</span><br><span class="line">  Map&lt;String, Exclusion&gt; ignoredFields = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">  ClassObj superClassObj = classInstance.getClassObj();</span><br><span class="line">  Exclusion classExclusion = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 将设置了“例外”的对象记录下来</span></span><br><span class="line">  <span class="comment">// 这里的“例外”就是上一个方法中提到的“例外”。是指那些低优先级的，或者说几乎不可能引发内存泄露的对象</span></span><br><span class="line">  <span class="comment">// 例如SDK中的一些对象，诸如Message, InputMethodManager等，一般情况下，这些对象都不会导致内存泄露。</span></span><br><span class="line">  <span class="comment">// 因此只有在遍历了其他对象之后，找不到泄露路径的情况下，才遍历这些对象。</span></span><br><span class="line">  <span class="keyword">while</span> (superClassObj != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Exclusion params = excludedRefs.classNames.get(superClassObj.getClassName());</span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// true overrides null or false.</span></span><br><span class="line">      <span class="comment">// 如果当前类或者其父类被设置了“例外”，则将其赋值给classExclusion</span></span><br><span class="line">      <span class="keyword">if</span> (classExclusion == <span class="keyword">null</span> || !classExclusion.alwaysExclude) &#123;</span><br><span class="line">        classExclusion = params;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前类及其父类包含例外的成员，将这些成员添加到ignoredFields中</span></span><br><span class="line">    Map&lt;String, Exclusion&gt; classIgnoredFields =</span><br><span class="line">        excludedRefs.fieldNameByClassName.get(superClassObj.getClassName());</span><br><span class="line">    <span class="keyword">if</span> (classIgnoredFields != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ignoredFields.putAll(classIgnoredFields);</span><br><span class="line">    &#125;</span><br><span class="line">    superClassObj = superClassObj.getSuperClassObj();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (classExclusion != <span class="keyword">null</span> &amp;&amp; classExclusion.alwaysExclude) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历每一个成员</span></span><br><span class="line">  <span class="keyword">for</span> (ClassInstance.FieldValue fieldValue : classInstance.getValues()) &#123;</span><br><span class="line">    Exclusion fieldExclusion = classExclusion;</span><br><span class="line">    Field field = fieldValue.getField();</span><br><span class="line">    <span class="comment">// 如果成员不是对象，则忽略</span></span><br><span class="line">    <span class="keyword">if</span> (field.getType() != Type.OBJECT) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取成员实例</span></span><br><span class="line">    Instance child = (Instance) fieldValue.getValue();</span><br><span class="line">    String fieldName = field.getName();</span><br><span class="line">    Exclusion params = ignoredFields.get(fieldName);</span><br><span class="line">    <span class="comment">// 如果当前成员对象是例外的，并且当前类和所有父类都不是例外的（classExclusion = null），</span></span><br><span class="line">    <span class="comment">// 或，如果当前成员对象时例外的，而且是alwaysExclude，而且当前类和父类都不是alwaysExclude</span></span><br><span class="line">    <span class="comment">// 则认为当前成员是需要例外处理的。</span></span><br><span class="line">    <span class="comment">// 这个逻辑很绕，实际上“||”后面的判断是不需要的，具体在enqueue方法中讲。</span></span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; (fieldExclusion == <span class="keyword">null</span> || (params.alwaysExclude</span><br><span class="line">        &amp;&amp; !fieldExclusion.alwaysExclude))) &#123;</span><br><span class="line">      fieldExclusion = params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队列</span></span><br><span class="line">    enqueue(fieldExclusion, node, child, fieldName, INSTANCE_FIELD);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Exclusion exclusion, LeakNode parent, Instance child, String referenceName,</span></span></span><br><span class="line"><span class="function"><span class="params">    LeakTraceElement.Type referenceType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isPrimitiveOrWrapperArray(child) || isPrimitiveWrapper(child)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Whether we want to visit now or later, we should skip if this is already to visit.</span></span><br><span class="line">  <span class="keyword">if</span> (toVisitSet.contains(child)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个exclusion就是上一个方法通过“很绕的”逻辑判断的出来的</span></span><br><span class="line">  <span class="comment">// 这里的作用就是如果为null则visitNow，这个boolean值在下面会用到。</span></span><br><span class="line">  <span class="comment">// 可以看到这里只是判断exclusion是否为null，并没有使用到alwaysExclude参数，</span></span><br><span class="line">  <span class="comment">// 所以说上一个方法中，“||”之后的判断是没有必要的。</span></span><br><span class="line">  <span class="keyword">boolean</span> visitNow = exclusion == <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!visitNow &amp;&amp; toVisitIfNoPathSet.contains(child)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (canIgnoreStrings &amp;&amp; isString(child)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (visitedSet.contains(child)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LeakNode childNode = <span class="keyword">new</span> LeakNode(exclusion, child, parent, referenceName, referenceType);</span><br><span class="line">  <span class="comment">// 这里用到了boolean值visitNow，就是说如果exclusion对象为null，则表示这不是一个例外的对象（暂且称之为常规对象）；</span></span><br><span class="line">  <span class="comment">// 如果exclusion对象不为null，则表示这个对象是例外对象，只有在遍历所有常规对象之后，还是找不到路径的情况下才会被遍历。</span></span><br><span class="line">  <span class="keyword">if</span> (visitNow) &#123;</span><br><span class="line">    toVisitSet.add(child);</span><br><span class="line">    toVisitQueue.add(childNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    toVisitIfNoPathSet.add(child);</span><br><span class="line">    toVisitIfNoPathQueue.add(childNode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本代码逻辑分析完毕。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h5 id="Q-LeakCanary为什么可以自动监视Activity？"><a href="#Q-LeakCanary为什么可以自动监视Activity？" class="headerlink" title="Q: LeakCanary为什么可以自动监视Activity？"></a>Q: LeakCanary为什么可以自动监视Activity？</h5><p>A: 答案在于<code>Application.ActivityLifecycleCallbacks</code>接口。具体可以查看<code>ActivityRefWatcher#watchActivities()</code>。</p><h5 id="Q-LeakCanary是在onDestroy-方法中对Activity添加监视。因为onDestroy-方法执行后，Instrumentation或其他一些类并没有立即释放对该Activity的强引用，那么它怎么保证得到正确的结果？"><a href="#Q-LeakCanary是在onDestroy-方法中对Activity添加监视。因为onDestroy-方法执行后，Instrumentation或其他一些类并没有立即释放对该Activity的强引用，那么它怎么保证得到正确的结果？" class="headerlink" title="Q: LeakCanary是在onDestroy()方法中对Activity添加监视。因为onDestroy()方法执行后，Instrumentation或其他一些类并没有立即释放对该Activity的强引用，那么它怎么保证得到正确的结果？"></a>Q: LeakCanary是在onDestroy()方法中对Activity添加监视。因为onDestroy()方法执行后，Instrumentation或其他一些类并没有立即释放对该Activity的强引用，那么它怎么保证得到正确的结果？</h5><p>A: LeakCanary是“异步”调用<code>ensureGone()</code>方法的。这个异步利用了IDLEHandler的原理。具体代码可查看<code>AndroidWatchExecutor</code>类中的相关方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;“A small leak will sink a great ship.”&lt;/em&gt;&lt;/strong&gt; - Benjamin Franklin&lt;/p&gt;
&lt;p&gt;【目录】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#离线配置&quot;&gt;离线配置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#下载离线aar包及依赖文件&quot;&gt;下载离线aar包及依赖文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#加入项目中&quot;&gt;加入项目中&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#编辑gradle文件&quot;&gt;编辑gradle文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#源码分析&quot;&gt;源码分析&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#判断是否泄露&quot;&gt;判断是否泄露&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#查找最短强引用路径&quot;&gt;查找最短强引用路径&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#附录&quot;&gt;附录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="第三方库" scheme="http://yoursite.com/categories/Android/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>GreenDao与Room对比以及Android SQLite API优化</title>
    <link href="http://yoursite.com/2018/03/29/Android-ORM/"/>
    <id>http://yoursite.com/2018/03/29/Android-ORM/</id>
    <published>2018-03-29T02:17:24.000Z</published>
    <updated>2018-03-30T15:03:58.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主流库"><a href="#主流库" class="headerlink" title="主流库"></a>主流库</h3><p>目前Android主流的ORM相关库可以分为两类，一类是我们熟知的基于SQLite并进行一系列封装和优化的框架，比如<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">GreenDao</a>、<a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="noopener">Room</a>、<a href="https://github.com/Raizlabs/DBFlow" target="_blank" rel="noopener">DBFlow</a>等；另一类是<a href="https://en.wikipedia.org/wiki/NoSQL" target="_blank" rel="noopener">NoSql</a>数据库（注意这一类是数据库，是SQLite的替代品），比如Realm。</p><a id="more"></a><h4 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h4><p>NoSql database也可以称为no relational database，即非关系型数据库。与关系型数据库不同，NoSql不存在复杂的关系模型，在数据库设计上更自然，没有了复杂的关系型模型，维护起来也更加容易。比如一篇博文中包含正文、评论等，关系型数据库在设计时会根据三范式，将正文和评论放到不同的表中，使用时需要进行联合查询。而面向文档的NoSql数据库可以将正文和评论都保存在一个文档中。在查询时，NoSql直接读取这一个文档即可，相比关系型数据库的多次查找会更快。而且NoSql更方便扩展，在分布式集群上，普通的关系型数据库的拆分与查询举步维艰（而且关系型数据库有数据量限制），而NoSql可以轻易地将不同的文档或者键值对保存在不同的服务器上，只需要使用合适的算法，查询也不是难事。</p><p>但是NoSql的缺点也同样明显。首先是难以实现复杂的查询。在关系型数据库中，我们往往可以轻易实现多表复杂联查，但是NoSql不支持联合查询，需要上层代码进行更多的处理，比如使用多次查询。其次是占用存储空间更多。运用关系型数据库三范式能够设计出精简巧妙的数据库，很好地降低数据冗余。但是NoSql则不然。比如上面提到的博文的例子，关系型数据库的“评论”表中只需要记录评论者的ID、评论文章ID、评论内容即可，至于评论者的详细信息，则由User表提供。但是在NoSql中，为了避免使用多次查询（因为多次查询需要上层代码进行更多处理），我们可能需要把博文中需要显示出来的评论者的信息——用户名、用户头像等——都保存在同一个文档中。这在一定程度上增加了存储空间的占用。试想，如果一个活跃用户评论了绝大多数的文章，那他的用户名和头像信息冗余就会非常严重。</p><p>在移动平台上，基于SQLite的ORM框架还有一个优势，就是引入之后不会对应用安装包体积产生明显的影响。基于以上对比，可以认为基于SQLite的ORM框架更加适合移动平台。</p><h4 id="SQLite-Based-ORMs的选择"><a href="#SQLite-Based-ORMs的选择" class="headerlink" title="SQLite Based ORMs的选择"></a>SQLite Based ORMs的选择</h4><p>一般选择以下两个：</p><ul><li>带头大哥 <a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">GreenDao</a></li><li>谷歌出品 <a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="noopener">Room</a></li></ul><p>直至目前，GreenDao都无疑是Android SQLite Based ORMs中的带头大哥，无论是Github Star数，还是各类博客中出现的次数，都稳居第一。而谷歌推出的持久化框架Room则有望与之齐平。</p><p>本文就选择这两个框架与传统SQLite API进行对比。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>分别从易用性和速度上进行对比。</p><h4 id="易用性对比"><a href="#易用性对比" class="headerlink" title="易用性对比"></a>易用性对比</h4><table><thead><tr><th style="text-align:left">GreenDao</th><th style="text-align:left">Room</th></tr></thead><tbody><tr><td style="text-align:left">开发者只需要规定Entity的属性即可</td><td style="text-align:left">需要规定Entity的属性，需要规定Dao接口</td></tr><tr><td style="text-align:left">每次更新Entity需要重新build以生成代码，大型项目build耗时会比较久</td><td style="text-align:left">更新Entity不需要重新build，因为使用的是Dao接口规定的方法，但是需要根据情况更新Dao接口</td></tr><tr><td style="text-align:left">只有进行复杂操作时才需要写SQL语句</td><td style="text-align:left">即使是进行简单的条件查询，也要写SQL语句</td></tr><tr><td style="text-align:left">有一定的学习成本，需要学习注解、查询、条件语句等API</td><td style="text-align:left">学习成本低，基本只需要掌握Room的注解即可</td></tr></tbody></table><p>很明显，如果熟悉SQL语句，那么Room会更容易上手，在开发中也相对更加便利。</p><h4 id="速度对比"><a href="#速度对比" class="headerlink" title="速度对比"></a>速度对比</h4><p>速度对比项有：</p><ul><li>插入数据 - 插入<code>1000</code>条<code>user</code>数据和<code>10000</code>条<code>message</code>数据</li><li>查询全部 - 查询所有(<code>10000</code>条)<code>message</code>数据</li></ul><p>使用每一个框架创建Disk Database，针对以上对比项分别测试50次并计时，结果取平均值，时间为ms。具体代码可以参考<a href="https://github.com/dxinl/android-orm-benchmark" target="_blank" rel="noopener">android-orm-benchmark</a>来实现，这里就不贴代码了。在HUAWEI Mate 10 Android 8.0.0上运行，得出结果如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">传统SQLite API</th><th style="text-align:center">GreenDao</th><th style="text-align:center">Room</th></tr></thead><tbody><tr><td style="text-align:center">插入数据</td><td style="text-align:center">5653</td><td style="text-align:center">2771</td><td style="text-align:center">1441</td></tr><tr><td style="text-align:center">查询全部</td><td style="text-align:center">611</td><td style="text-align:center">750</td><td style="text-align:center">411</td></tr></tbody></table><p>可以看出，<code>Room</code>在查询和写入上的速度超过了<code>传统SQLite API</code>和<code>GreenDao</code>，甚至<code>GreenDao</code>在查询速度上会比<code>传统SQLite API</code>慢。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>为什么<code>Room</code>和<code>GreenDao</code>在写入的速度上会比<code>传统SQLite API</code>快这么多？首先来看一下每次<code>传统SQLite API</code>在写入时执行的几个步骤：</p><ol><li>组装<code>ContentValues</code></li><li>拼接SQL语句</li><li>将<code>ContentValues</code>转换为数组</li><li>创建<code>SQLiteStatement</code></li><li>将<code>SQLiteStatement</code>与第3步的数组绑定</li><li>执行写入操作</li></ol><p>而<code>Room</code>只需要两步：</p><ol><li>将SQLiteStatement与要插入的数据绑定</li><li>执行写入操作</li></ol><p>这就是<code>Room</code>比<code>传统SQLite API</code>快的原因。通过缓存<code>SQLiteStatement</code>，避免了每写一行都需要重新拼接SQL语句、创建<code>SQLiteStatement</code>这些重复操作。同时，由于掌握了<code>SQLiteStatement</code>，可以直接绑定数据，不再需要依赖<code>ContentValues</code>，避免了组装和反组装的耗时。</p><p>而由于<code>GreenDao</code>会把要写入的对象缓存起来，如果已经缓存过就更新，以此来提高查询速度，所以会有更多的时间消耗。实际上，在<code>速度对比</code>这一节中，我们先清除了<code>GreenDao</code>的对象缓存再执行查询，因为缓存无法命中，需要使用Cursor生成对象。尽管<code>GreenDao</code>在遍历Cursor生成对象这一步有所优化，但是其对速度的提升幅度相对查询缓存来说是很小的，所以其速度会比<code>传统SQLite API</code>更慢。在上述测试代码中，如果不清除缓存，<code>GreenDao</code>查询速度会有2~3倍的提升（随着数据量的增加，这个提升会有所下降）。由于<code>GreenDao</code>的缓存对象与返回的查询结果是同一对象，因此需要特别注意，在开启缓存的情况下，如果直接修改查询出来的对象，而且没有及时同步到数据库中，那么就会导致下次查询结果错误与数据库不同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DaoSession session = mDaoMaster.newSession();</span><br><span class="line">Message msg = session.getMessageDao().queryBuilder()</span><br><span class="line">        .where(MessageDao.Properties.Id.eq(<span class="number">1</span>)).unique();;</span><br><span class="line">Log.e(<span class="string">"before"</span>, msg.toString());</span><br><span class="line"></span><br><span class="line">msg.content = <span class="string">"modified"</span>;</span><br><span class="line">Message message1 = session.getMessageDao().queryBuilder()</span><br><span class="line">        .where(MessageDao.Properties.Id.eq(msg.id)).unique();</span><br><span class="line">Log.e(<span class="string">"after"</span>, message1.toString());</span><br></pre></td></tr></table></figure><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E/before: 1, JkJsHimdMNwLF9WWsJR8Vj5uea5uqPDlSzve2raGK6t0u6qwEZopLbi80KHDapqcEJiugixqHqUhhavmlOz9OGB2EnFAD3Mj9Qnt</span><br><span class="line">E/after: 1, modified</span><br></pre></td></tr></table></figure></p><p>考虑到部分项目可能会选择关闭这个功能（如果你的项目中确定要关闭<code>GreenDao</code>缓存，那么<code>Room</code>会是你更好的选择），因此测试代码选择每次执行数据库操作后，清除缓存。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>同样地，<code>传统SQLite API</code>执行查询也需要每次都拼接SQL语句。而且在查询完成得到<code>Cursor</code>之后，我们在使用<code>传统SQLite API</code>生成对象时，一般会在循环体中进行列下标查询，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getColumnIndex every time</span></span><br><span class="line"><span class="keyword">while</span> (c != <span class="keyword">null</span> &amp;&amp; c.moveToNext()) &#123;</span><br><span class="line">    Message newMessage = <span class="keyword">new</span> Message();</span><br><span class="line">    newMessage.setChannelId(c.getLong(c</span><br><span class="line">            .getColumnIndex(Message.CHANNEL_ID)));</span><br><span class="line">    newMessage.setClientId(c.getLong(c</span><br><span class="line">            .getColumnIndex(Message.CLIENT_ID)));</span><br><span class="line">    newMessage.setCommandId(c.getLong(c</span><br><span class="line">            .getColumnIndex(Message.COMMAND_ID)));</span><br><span class="line">    newMessage.setContent(c.getString(c</span><br><span class="line">            .getColumnIndex(Message.CONTENT)));</span><br><span class="line">    newMessage.setCreatedAt(c.getInt(c</span><br><span class="line">            .getColumnIndex(Message.CREATED_AT)));</span><br><span class="line">    newMessage.setSenderId(c.getLong(c</span><br><span class="line">            .getColumnIndex(Message.SENDER_ID)));</span><br><span class="line">    newMessage.setSortedBy(c.getDouble(c</span><br><span class="line">            .getColumnIndex(Message.SORTED_BY)));</span><br><span class="line"></span><br><span class="line">    messages.add(newMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而<code>Room</code>只会查询一次下标：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Code generated by Room</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfId = _cursor.getColumnIndexOrThrow(<span class="string">"_id"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfClientId = _cursor.getColumnIndexOrThrow(<span class="string">"client_id"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfCommandId = _cursor.getColumnIndexOrThrow(<span class="string">"command_id"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfSortedBy = _cursor.getColumnIndexOrThrow(<span class="string">"sorted_by"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfCreatedAt = _cursor.getColumnIndexOrThrow(<span class="string">"created_at"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfContent = _cursor.getColumnIndexOrThrow(<span class="string">"content"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfSenderId = _cursor.getColumnIndexOrThrow(<span class="string">"sender_id"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> _cursorIndexOfChannelId = _cursor.getColumnIndexOrThrow(<span class="string">"channel_id"</span>);</span><br><span class="line"><span class="keyword">final</span> RoomMessage[] _result = <span class="keyword">new</span> RoomMessage[_cursor.getCount()];</span><br><span class="line"><span class="keyword">int</span> _index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(_cursor.moveToNext()) &#123;</span><br><span class="line">  <span class="keyword">final</span> RoomMessage _item;</span><br><span class="line">  _item = <span class="keyword">new</span> RoomMessage();</span><br><span class="line">  _item.id = _cursor.getLong(_cursorIndexOfId);</span><br><span class="line">  _item.clientId = _cursor.getLong(_cursorIndexOfClientId);</span><br><span class="line">  _item.commandId = _cursor.getLong(_cursorIndexOfCommandId);</span><br><span class="line">  _item.sortedBy = _cursor.getDouble(_cursorIndexOfSortedBy);</span><br><span class="line">  _item.createdAt = _cursor.getInt(_cursorIndexOfCreatedAt);</span><br><span class="line">  _item.content = _cursor.getString(_cursorIndexOfContent);</span><br><span class="line">  _item.senderId = _cursor.getLong(_cursorIndexOfSenderId);</span><br><span class="line">  _item.channelId = _cursor.getLong(_cursorIndexOfChannelId);</span><br><span class="line">  _result[_index] = _item;</span><br><span class="line">  _index ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _result;</span><br></pre></td></tr></table></figure></p><h3 id="SQLite-API优化"><a href="#SQLite-API优化" class="headerlink" title="SQLite API优化"></a>SQLite API优化</h3><p>其实通过上一节的分析，大家应该已经有了优化的思路。没错，就是照抄Room：</p><ol><li><p>自己生成和管理<code>SQLiteStatement</code>，杜绝ContentValues和拼接SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQLiteStatement insertMessage = db.compileStatement(</span><br><span class="line">        String.format(<span class="string">"Insert into %s (%s, %s, %s, %s, %s, %s, %s) values (?,?,?,?,?,?,?)"</span>,</span><br><span class="line">            OptimizedMessage.TABLE_NAME,</span><br><span class="line">            OptimizedMessage.CONTENT,</span><br><span class="line">            OptimizedMessage.SORTED_BY,</span><br><span class="line">            OptimizedMessage.CLIENT_ID,</span><br><span class="line">            OptimizedMessage.SENDER_ID,</span><br><span class="line">            OptimizedMessage.CHANNEL_ID,</span><br><span class="line">            OptimizedMessage.COMMAND_ID,</span><br><span class="line">            OptimizedMessage.CREATED_AT ));</span><br></pre></td></tr></table></figure></li><li><p>在遍历Cursor前获取列下标，而不是在循环体中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do these things outside the while syntax</span></span><br><span class="line"><span class="keyword">int</span> channelIdIndex = c.getColumnIndex(OptimizedMessage.CHANNEL_ID);</span><br><span class="line"><span class="keyword">int</span> clientIdIndex = c.getColumnIndex(OptimizedMessage.CLIENT_ID);</span><br><span class="line"><span class="keyword">int</span> commandIdIndex = c.getColumnIndex(OptimizedMessage.COMMAND_ID);</span><br><span class="line"><span class="keyword">int</span> contentIndex = c.getColumnIndex(OptimizedMessage.CONTENT);</span><br><span class="line"><span class="keyword">int</span> createdAtIndex = c.getColumnIndex(OptimizedMessage.CREATED_AT);</span><br><span class="line"><span class="keyword">int</span> senderIdIndex = c.getColumnIndex(OptimizedMessage.SENDER_ID);</span><br><span class="line"><span class="keyword">int</span> sortedByIndex = c.getColumnIndex(OptimizedMessage.SORTED_BY);</span><br></pre></td></tr></table></figure></li></ol><p>以上两点就是通过对比<code>Room</code>得出的优化方案，应用到测试代码中之后，写入和查询速度有了明显的提升：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优化前</th><th style="text-align:center">优化后</th><th style="text-align:center">GreenDao</th><th style="text-align:center">Room</th></tr></thead><tbody><tr><td style="text-align:center">写入</td><td style="text-align:center">5653</td><td style="text-align:center">1865</td><td style="text-align:center">2771</td><td style="text-align:center">1441</td></tr><tr><td style="text-align:center">查询</td><td style="text-align:center">611</td><td style="text-align:center">536</td><td style="text-align:center">750</td><td style="text-align:center">411</td></tr></tbody></table><p>除了上述借鉴<code>Room</code>和<code>GreenDao</code>的优化之外，还有一些基本知识，比如“在同一个事务中完成多行写入操作，而不是每写入一行都开启一个事务”等，也可以大大提升写入（查询）速度。优化无处不在，借鉴优秀的第三方框架，能够快速地学习如何写好代码。而扎实的基础是一切优化的前提。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主流库&quot;&gt;&lt;a href=&quot;#主流库&quot; class=&quot;headerlink&quot; title=&quot;主流库&quot;&gt;&lt;/a&gt;主流库&lt;/h3&gt;&lt;p&gt;目前Android主流的ORM相关库可以分为两类，一类是我们熟知的基于SQLite并进行一系列封装和优化的框架，比如&lt;a href=&quot;https://github.com/greenrobot/greenDAO&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GreenDao&lt;/a&gt;、&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/room.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Room&lt;/a&gt;、&lt;a href=&quot;https://github.com/Raizlabs/DBFlow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DBFlow&lt;/a&gt;等；另一类是&lt;a href=&quot;https://en.wikipedia.org/wiki/NoSQL&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NoSql&lt;/a&gt;数据库（注意这一类是数据库，是SQLite的替代品），比如Realm。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="第三方库" scheme="http://yoursite.com/categories/Android/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>【坑】RecyclerView与EditText</title>
    <link href="http://yoursite.com/2018/03/02/trap-recyclerview-edittext/"/>
    <id>http://yoursite.com/2018/03/02/trap-recyclerview-edittext/</id>
    <published>2018-03-02T03:43:37.000Z</published>
    <updated>2018-03-30T15:04:45.651Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h4><p>使用<code>RecyclerView</code>实现富文本编辑器，包含三种<code>ItemType</code>，分别是<code>Text</code>、<code>Todo</code>和<code>Image</code>。由于输入需要，每种item都有EditText，而RecyclerView在滚动的过程中，会将<code>ItemView</code>移除，并再次<code>attach</code>，这个过程会造成<code>ItemView</code>的焦点丢失，因此需要记录焦点所在的因此需要记录焦点所在的<code>position</code>，当该<code>pisition</code>重新显示在屏幕上时，为<code>ItemView</code>请求焦点。</p><p>下面将列出在开发过程中遇到的难点和解决方案。</p><a id="more"></a><h3 id="1-长按无法呼出上下文操作菜单？"><a href="#1-长按无法呼出上下文操作菜单？" class="headerlink" title="1. 长按无法呼出上下文操作菜单？"></a>1. 长按无法呼出上下文操作菜单？</h3><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>由于在onBindViewHolder时，会调用<code>EditText#setText(CharSequence)</code>方法，该方法会产生如下方法堆栈（调用关系为由上及下）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> TextView#setText(CharSequence)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> TextView#checkForRelayout()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> TextView#makeNewLayout(int, int, BoringLayout.Metrics,</span></span><br><span class="line"><span class="comment"> *                             BoringLayout.Metrics, int, boolean)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Editor#prepareCursorControllers()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>在<code>Editor#prepareCursorControllers()</code>会给决定能否呼出上下文操作菜单的变量<code>mInsertionControllerEnabled</code>、<code>mSelectionControllerEnabled</code>赋值。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepareCursorControllers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> windowSupportsHandles = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在onBindViewHolder时，Item还没有添加到RecyclerView中，其RootView不是Window，</span></span><br><span class="line">    <span class="comment">// LayoutParams不是WindowManager.LayoutParams的实例，因此后续的两个变量都为false，</span></span><br><span class="line">    <span class="comment">// 导致长按无法呼出上下文操作菜单。</span></span><br><span class="line">    ViewGroup.LayoutParams params = mTextView.getRootView().getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (params <span class="keyword">instanceof</span> WindowManager.LayoutParams) &#123;</span><br><span class="line">        WindowManager.LayoutParams windowParams = (WindowManager.LayoutParams) params;</span><br><span class="line">        windowSupportsHandles = windowParams.type &lt; WindowManager.LayoutParams.FIRST_SUB_WINDOW</span><br><span class="line">                || windowParams.type &gt; WindowManager.LayoutParams.LAST_SUB_WINDOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> enabled = windowSupportsHandles &amp;&amp; mTextView.getLayout() != <span class="keyword">null</span>;</span><br><span class="line">    mInsertionControllerEnabled = enabled &amp;&amp; isCursorVisible();</span><br><span class="line">    mSelectionControllerEnabled = enabled &amp;&amp; mTextView.textCanBeSelected();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInsertionControllerEnabled) &#123;</span><br><span class="line">        hideInsertionPointCursorController();</span><br><span class="line">        <span class="keyword">if</span> (mInsertionPointCursorController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInsertionPointCursorController.onDetached();</span><br><span class="line">            mInsertionPointCursorController = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mSelectionControllerEnabled) &#123;</span><br><span class="line">        stopTextActionMode();</span><br><span class="line">        <span class="keyword">if</span> (mSelectionModifierCursorController != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSelectionModifierCursorController.onDetached();</span><br><span class="line">            mSelectionModifierCursorController = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在Item添加到RecyclerView中之后，再次调用<code>Editor#prepareCursorControllers()</code>方法。<br>因为该方法是包私有（<code>package-private</code>）方法，因此需要使用反射来调用。为了避免多次查找<code>Field</code>、<code>Method</code>的消耗，可以使用成员变量保存反射过程中找到的<code>Field</code>和<code>Method</code>。</p><h3 id="2-输入框请求焦点导致滚动自动停止？"><a href="#2-输入框请求焦点导致滚动自动停止？" class="headerlink" title="2. 输入框请求焦点导致滚动自动停止？"></a><a id="2" href="#2" class="anchor" aria-hidden="true"></a>2. 输入框请求焦点导致滚动自动停止？</h3><h4 id="原因分析-1"><a href="#原因分析-1" class="headerlink" title="原因分析"></a>原因分析</h4><p>当一个拥有焦点的<code>position</code>离开并再次进入屏幕时，首先会为该<code>position</code>对应的<code>ItemView</code>请求焦点，接着会进行Layout，发生以下方法堆栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ViewRootImpl#performTraversals()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ViewTreeObserver#dispatchOnPreDraw()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> TextView#onPreDraw()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> TextView#bringPointIntoView()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>看一下<code>TextView#bringPointIntoView()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bringPointIntoView</span><span class="params">(<span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处省略大量无关代码，此部分代码用于计算光标所在矩形的位置。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFocused()) &#123;</span><br><span class="line">        <span class="comment">// This offsets because getInterestingRect() is in terms of viewport coordinates, but</span></span><br><span class="line">        <span class="comment">// requestRectangleOnScreen() is in terms of content coordinates.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The offsets here are to ensure the rectangle we are using is</span></span><br><span class="line">        <span class="comment">// within our view bounds, in case the cursor is on the far left</span></span><br><span class="line">        <span class="comment">// or right.  If it isn't withing the bounds, then this request</span></span><br><span class="line">        <span class="comment">// will be ignored.</span></span><br><span class="line">        <span class="keyword">if</span> (mTempRect == <span class="keyword">null</span>) mTempRect = <span class="keyword">new</span> Rect();</span><br><span class="line">        mTempRect.set(x - <span class="number">2</span>, top, x + <span class="number">2</span>, bottom);</span><br><span class="line">        getInterestingRect(mTempRect, line);</span><br><span class="line">        mTempRect.offset(mScrollX, mScrollY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// requestRectangleOnScreen()方法会请求此View中的一个矩形显示在屏幕上</span></span><br><span class="line">        <span class="keyword">if</span> (requestRectangleOnScreen(mTempRect)) &#123;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>View#requestRectangleOnScreen(Rect)</code>会遍历所有的父View并调用它们的<code>requestChildRectangleOnScreen</code>方法，整个方法会将子View指定的矩形区域显示到屏幕上。在<code>RecyclerView</code>中，该方法会调用<code>RecyclerView#smoothScrollBy(int, int)</code>方法触发滚动，这个方法会先取消之前的滚动，并开始此次滚动。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>在用户滚动时，禁用请求显示child的功能。通过增加<code>onScrollListener</code>即可监听滚动状态的变化。如果滚动状态是<code>SCROLL_STATE_DRAGGING</code>，或者滚动状态从<code>SCROLL_STATE_DRAGGING</code>变化为<code>SCROLL_STATE_SETTLING</code>则表示用户触发了此次滚动（DRAGGING表示手指还未离开屏幕，DRAGGING之后的SETTLING表示手指离开屏幕但是尚在滚动）。</p><h3 id="3-长item获取焦点后上下滚动？"><a href="#3-长item获取焦点后上下滚动？" class="headerlink" title="3. 长item获取焦点后上下滚动？"></a>3. 长item获取焦点后上下滚动？</h3><h4 id="原因分析-2"><a href="#原因分析-2" class="headerlink" title="原因分析"></a>原因分析</h4><p>一个十几页长的文本item，点击进入编辑状态时，其首选滚动到文本顶部，再滚动到点击的位置，并显示光标。通过分析代码，发现是子View获取焦点后，RecyclerView会滚动以将其显示在屏幕上。具体方法堆栈如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> View#requestFocus()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> View#handleFocusGainInternal(int, Rect)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> RecyclerView#requestChildFocus(View, View)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> RecyclerView#requestChildOnScreen(View, View)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>看一下<code>RecyclerView#requestChildOnScreen(View, View)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestChildOnScreen</span><span class="params">(@NonNull View child, @Nullable View focused)</span> </span>&#123;</span><br><span class="line">    View rectView = (focused != <span class="keyword">null</span>) ? focused : child;</span><br><span class="line">    mTempRect.set(<span class="number">0</span>, <span class="number">0</span>, rectView.getWidth(), rectView.getHeight());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get item decor offsets w/o refreshing. If they are invalid, there will be another</span></span><br><span class="line">    <span class="comment">// layout pass to fix them, then it is LayoutManager's responsibility to keep focused</span></span><br><span class="line">    <span class="comment">// View in viewport.</span></span><br><span class="line">    <span class="keyword">final</span> ViewGroup.LayoutParams focusedLayoutParams = rectView.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (focusedLayoutParams <span class="keyword">instanceof</span> LayoutParams) &#123;</span><br><span class="line">        <span class="comment">// if focused child has item decors, use them. Otherwise, ignore.</span></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) focusedLayoutParams;</span><br><span class="line">        <span class="keyword">if</span> (!lp.mInsetsDirty) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect insets = lp.mDecorInsets;</span><br><span class="line">            mTempRect.left -= insets.left;</span><br><span class="line">            mTempRect.right += insets.right;</span><br><span class="line">            mTempRect.top -= insets.top;</span><br><span class="line">            mTempRect.bottom += insets.bottom;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</span><br><span class="line">        offsetDescendantRectToMyCoords(focused, mTempRect);</span><br><span class="line">        offsetRectIntoDescendantCoords(child, mTempRect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以知道mTempRect实际上是整个child所在的矩形。</span></span><br><span class="line">    mLayout.requestChildRectangleOnScreen(<span class="keyword">this</span>, child, mTempRect, !mFirstLayoutComplete,</span><br><span class="line">            (focused == <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将滚动的请求发送给<code>LayoutManager</code>，<code>LayoutManager</code>先计算出滚动的距离，然后执行滚动。来看一下具体过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestChildRectangleOnScreen</span><span class="params">(RecyclerView parent, View child, Rect rect,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> immediate,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> focusedChildVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算需要滚动的距离</span></span><br><span class="line">    <span class="keyword">int</span>[] scrollAmount = getChildRectangleOnScreenScrollAmount(parent, child, rect,</span><br><span class="line">            immediate);</span><br><span class="line">    <span class="keyword">int</span> dx = scrollAmount[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> dy = scrollAmount[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!focusedChildVisible || isFocusedChildVisibleAfterScrolling(parent, dx, dy)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行滚动</span></span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">                parent.scrollBy(dx, dy);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent.smoothScrollBy(dx, dy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getChildRectangleOnScreenScrollAmount(RecyclerView parent, View child,</span><br><span class="line">        Rect rect, <span class="keyword">boolean</span> immediate) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] out = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeft();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTop();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = getWidth() - getPaddingRight();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = getHeight() - getPaddingBottom();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childLeft = child.getLeft() + rect.left - child.getScrollX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childTop = child.getTop() + rect.top - child.getScrollY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childRight = childLeft + rect.width();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childBottom = childTop + rect.height();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offScreenLeft = Math.min(<span class="number">0</span>, childLeft - parentLeft);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offScreenTop = Math.min(<span class="number">0</span>, childTop - parentTop);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offScreenRight = Math.max(<span class="number">0</span>, childRight - parentRight);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offScreenBottom = Math.max(<span class="number">0</span>, childBottom - parentBottom);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算x轴方向滚动距离，与本次分析的问题关联不大。</span></span><br><span class="line">    <span class="comment">// Favor the "start" layout direction over the end when bringing one side or the other</span></span><br><span class="line">    <span class="comment">// of a large rect into view. If we decide to bring in end because start is already</span></span><br><span class="line">    <span class="comment">// visible, limit the scroll such that start won't go out of bounds.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dx;</span><br><span class="line">    <span class="keyword">if</span> (getLayoutDirection() == ViewCompat.LAYOUT_DIRECTION_RTL) &#123;</span><br><span class="line">        dx = offScreenRight != <span class="number">0</span> ? offScreenRight</span><br><span class="line">                : Math.max(offScreenLeft, childRight - parentRight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dx = offScreenLeft != <span class="number">0</span> ? offScreenLeft</span><br><span class="line">                : Math.min(childLeft - parentLeft, offScreenRight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算y轴方向滚动距离，“优先于将child的顶部显示出来，而不是底部，如果顶部已经显示了，并且要滚动以显示底部，则需要保证顶部不会滚动到屏幕外”。</span></span><br><span class="line">    <span class="comment">// Favor bringing the top into view over the bottom. If top is already visible and</span></span><br><span class="line">    <span class="comment">// we should scroll to make bottom visible, make sure top does not go out of bounds.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dy = offScreenTop != <span class="number">0</span> ? offScreenTop</span><br><span class="line">            : Math.min(childTop - parentTop, offScreenBottom);</span><br><span class="line">    out[<span class="number">0</span>] = dx;</span><br><span class="line">    out[<span class="number">1</span>] = dy;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是在进入编辑模式时，长item先往上滚动的原因。而往下滚动则与<a href="#2">第二个问题</a>一致。当<code>layout</code>执行完后，<code>TextView#onPreDraw()</code>会计算出光标所在的矩形，并请求父View显示此矩形，因此发生了向下滚动的过程。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>当我们需要点击一个编辑项，进入编辑模式时，实际上光标位置一定不会是在屏幕在外。唯一存在的滚动需求是，当编辑项获取焦点后，输入法会弹出来，如果点击的位置在屏幕下方，就会被输入法遮挡，因此需要在重新<code>layout</code>之后滚动到光标位置，不存在将child顶部显示出来的需求。因此只需覆写<code>RecyclerView.LayoutManager#requestChildRectangleOnScreen(RecyclerView, View, Rect ,boolean)</code>方法，执行判断，如果y轴方向上滚动的距离为负数，则不滚动。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h4&gt;&lt;p&gt;使用&lt;code&gt;RecyclerView&lt;/code&gt;实现富文本编辑器，包含三种&lt;code&gt;ItemType&lt;/code&gt;，分别是&lt;code&gt;Text&lt;/code&gt;、&lt;code&gt;Todo&lt;/code&gt;和&lt;code&gt;Image&lt;/code&gt;。由于输入需要，每种item都有EditText，而RecyclerView在滚动的过程中，会将&lt;code&gt;ItemView&lt;/code&gt;移除，并再次&lt;code&gt;attach&lt;/code&gt;，这个过程会造成&lt;code&gt;ItemView&lt;/code&gt;的焦点丢失，因此需要记录焦点所在的因此需要记录焦点所在的&lt;code&gt;position&lt;/code&gt;，当该&lt;code&gt;pisition&lt;/code&gt;重新显示在屏幕上时，为&lt;code&gt;ItemView&lt;/code&gt;请求焦点。&lt;/p&gt;
&lt;p&gt;下面将列出在开发过程中遇到的难点和解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="坑" scheme="http://yoursite.com/categories/Android/%E5%9D%91/"/>
    
    
  </entry>
  
  <entry>
    <title>【坑】RelativeLayout与wrap_content</title>
    <link href="http://yoursite.com/2018/03/02/trap-relative-warpcontent/"/>
    <id>http://yoursite.com/2018/03/02/trap-relative-warpcontent/</id>
    <published>2018-03-02T03:33:42.000Z</published>
    <updated>2018-03-30T15:05:16.277Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，遇到了一个问题：将<code>RelativeLayout</code>的高度从固定值180dp，修改为<code>wrap_content</code> + <code>minHeight</code>之后，高度为<code>match_parent</code>的子View <code>LinearLayout</code>在测量后就会变成<code>wrap_content</code>。</p><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- item.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:minHeight</span>=<span class="string">"180dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"?android:attr/selectableItemBackground"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">"@+id/linearLayout"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_centerVertical</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_alignParentEnd</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:gravity</span>=<span class="string">"center_vertical"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 省略 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="经过分析，原因如下："><a href="#经过分析，原因如下：" class="headerlink" title="经过分析，原因如下："></a>经过分析，原因如下：</h3><p>因为该<code>RelativeLayout</code>是作为<code>RecyclerView</code>的<code>item</code>被使用的，来看一下<code>RecyclerView</code>的<code>getChildMeasureSpec(int, int, int, boolean)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> parentSize, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> canScroll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, parentSize - padding);</span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (canScroll) &#123;</span><br><span class="line">        <span class="comment">// MATCH_PARENT = -1</span></span><br><span class="line">        <span class="comment">// WRAP_CONTENT = -2</span></span><br><span class="line">        <span class="comment">// 大于等于0表示为该Item的Layout设置了固定的大小。</span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// MATCH_PARENT can't be applied since we can scroll in this dimension, wrap</span></span><br><span class="line">            <span class="comment">// instead using UNSPECIFIED.</span></span><br><span class="line">            resultSize = <span class="number">0</span>;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，可以看出，<code>RecyclerView</code>在measure item的时候，传递了一个由 <code>size = 0, measureSpecMode = UNSPECIFIED</code> 生成的<code>measureSpec</code>。接下来看一下<code>RelativeLayout</code>的<code>onMeasure(int, int)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">int</span> myHeight = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="keyword">if</span> (heightMode != MeasureSpec.UNSPECIFIED) &#123;</span><br><span class="line">        myHeight = heightSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = views[i];</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">// ...省略</span></span><br><span class="line">            <span class="comment">// 此方法根据子View配置的垂直方向上的各种RelativeLayout rules进行计算</span></span><br><span class="line">            <span class="comment">// 如果有rules，那么就会给RelativeLayout.LayoutParams的私有成员mTop/mBottom赋值。</span></span><br><span class="line">            <span class="comment">// 垂直方向上的rules包括ALIGN_PARENT_BOTTOM、ABOVE、BELOW等。</span></span><br><span class="line">            <span class="comment">// 从布局文件可知，此处不会给mTop/mBottom赋值。</span></span><br><span class="line">            applyVerticalSizeRules(params, myHeight, child.getBaseline());</span><br><span class="line">            measureChild(child, params, myWidth, myHeight);</span><br><span class="line">            <span class="comment">// ...省略</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合<code>RecyclerView</code>代码可知，<code>myHeight = -1</code>。再看<code>measureChild(View, LayoutParams , int, int)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, LayoutParams params, <span class="keyword">int</span> myWidth, <span class="keyword">int</span> myHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 从上述可知，params.mTop params.mBottom均没有设置。</span></span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(params.mTop,</span><br><span class="line">            params.mBottom, params.height,</span><br><span class="line">            params.topMargin, params.bottomMargin,</span><br><span class="line">            mPaddingTop, mPaddingBottom,</span><br><span class="line">            myHeight);</span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续追踪<code>getChildMeasureSpec(int, int, int, int, int, int, int, int)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> childStart, <span class="keyword">int</span> childEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> childSize, <span class="keyword">int</span> startMargin, <span class="keyword">int</span> endMargin, <span class="keyword">int</span> startPadding,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> endPadding, <span class="keyword">int</span> mySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childSpecMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childSpecSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Negative values in a mySize value in RelativeLayout</span></span><br><span class="line">    <span class="comment">// measurement is code for, "we got an unspecified mode in the</span></span><br><span class="line">    <span class="comment">// RelativeLayout's measure spec."</span></span><br><span class="line">    <span class="comment">// 由上述分析可知mySize = -1，childSize = MATCH_PARENT = -1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isUnspecified = mySize &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// mAllowBrokenMeasureSpecs是为了修复低版本bug引入的变量，只有在API &lt;= 17时才为true</span></span><br><span class="line">    <span class="keyword">if</span> (isUnspecified &amp;&amp; !mAllowBrokenMeasureSpecs) &#123;</span><br><span class="line">        <span class="comment">// 此处似乎隐含修复bug的可能。只要保证子view的LayoutParams的mTop/mBottom被设置就行了。</span></span><br><span class="line">        <span class="keyword">if</span> (childStart != VALUE_NOT_SET &amp;&amp; childEnd != VALUE_NOT_SET) &#123;</span><br><span class="line">            <span class="comment">// Constraints fixed both edges, so child has an exact size.</span></span><br><span class="line">            childSpecSize = Math.max(<span class="number">0</span>, childEnd - childStart);</span><br><span class="line">            childSpecMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childSize &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// The child specified an exact size.</span></span><br><span class="line">            childSpecSize = childSize;</span><br><span class="line">            childSpecMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Allow the child to be whatever size it wants.</span></span><br><span class="line">            <span class="comment">// 最后走了这里</span></span><br><span class="line">            childSpecSize = <span class="number">0</span>;</span><br><span class="line">            childSpecMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述分析，我们了解了产生bug的原因。<strong>那么是否有可能修复这个bug？</strong><br>前面代码分析中，写了一句“此处似乎隐含修复bug的可能”，是否真的有可能呢？让我们重新分析一下<code>applyVerticalSizeRules(LayoutParams, int, int)</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyVerticalSizeRules</span><span class="params">(LayoutParams childParams, <span class="keyword">int</span> myHeight, <span class="keyword">int</span> myBaseline)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] rules = childParams.getRules();</span><br><span class="line">    <span class="comment">// Baseline alignment overrides any explicitly specified top or bottom.</span></span><br><span class="line">    <span class="comment">// 如果设置了baseLine则以baseLine为基础设置mTop/mBottom。</span></span><br><span class="line">    <span class="keyword">int</span> baselineOffset = getRelatedViewBaselineOffset(rules);</span><br><span class="line">    <span class="keyword">if</span> (baselineOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myBaseline != -<span class="number">1</span>) &#123;</span><br><span class="line">            baselineOffset -= myBaseline;</span><br><span class="line">        &#125;</span><br><span class="line">        childParams.mTop = baselineOffset;</span><br><span class="line">        <span class="comment">// 设置baseLine不能改变mBottm的值，不符合条件。</span></span><br><span class="line">        childParams.mBottom = VALUE_NOT_SET;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 由布局文件可知该子View是顶部和头部是不存在其他View的，因此设置ABOVE/BELOW等属性均不可能。</span></span><br><span class="line">    RelativeLayout.LayoutParams anchorParams;</span><br><span class="line">    childParams.mTop = VALUE_NOT_SET;</span><br><span class="line">    childParams.mBottom = VALUE_NOT_SET;</span><br><span class="line">    anchorParams = getRelatedViewParams(rules, ABOVE);</span><br><span class="line">    <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        childParams.mBottom = anchorParams.mTop - (anchorParams.topMargin +</span><br><span class="line">                childParams.bottomMargin);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ABOVE] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            childParams.mBottom = myHeight - mPaddingBottom - childParams.bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    anchorParams = getRelatedViewParams(rules, BELOW);</span><br><span class="line">    <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        childParams.mTop = anchorParams.mBottom + (anchorParams.bottomMargin +</span><br><span class="line">                childParams.topMargin);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[BELOW] != <span class="number">0</span>) &#123;</span><br><span class="line">        childParams.mTop = mPaddingTop + childParams.topMargin;</span><br><span class="line">    &#125;</span><br><span class="line">    anchorParams = getRelatedViewParams(rules, ALIGN_TOP);</span><br><span class="line">    <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        childParams.mTop = anchorParams.mTop + childParams.topMargin;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_TOP] != <span class="number">0</span>) &#123;</span><br><span class="line">        childParams.mTop = mPaddingTop + childParams.topMargin;</span><br><span class="line">    &#125;</span><br><span class="line">    anchorParams = getRelatedViewParams(rules, ALIGN_BOTTOM);</span><br><span class="line">    <span class="keyword">if</span> (anchorParams != <span class="keyword">null</span>) &#123;</span><br><span class="line">        childParams.mBottom = anchorParams.mBottom - childParams.bottomMargin;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childParams.alignWithParent &amp;&amp; rules[ALIGN_BOTTOM] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            childParams.mBottom = myHeight - mPaddingBottom - childParams.bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置ALIGN_PARENT_TOP可以使mTop得到值。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_TOP]) &#123;</span><br><span class="line">        childParams.mTop = mPaddingTop + childParams.topMargin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为myHeight = -1，所以设置ALIGN_PARENT_BOTTOM不能使mBottom得到值。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != rules[ALIGN_PARENT_BOTTOM]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (myHeight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            childParams.mBottom = myHeight - mPaddingBottom - childParams.bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">***</span><br></pre></td></tr></table></figure><p>经过上述分析，在现有布局条件下，无法通过为子View增加一些rules来修复这个bug。只能通过布局调整来修复。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个bug实际上是普遍存在的。如果要求<code>RecyclerView</code>的itemView的子view的高度是match_parent，应该尽可能避免使用<code>RelativeLayout</code>的<code>layout_height=&quot;match_parent&quot;  minHeight=&quot;xxxdp&quot;</code>的写法，或者使用其他Layout。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本文援引的源码如下：</p><p><a href="http://androidxref.com/7.1.1_r6/xref/frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.java" target="_blank" rel="noopener">RecyclerView</a></p><p><a href="http://androidxref.com/7.0.0_r1/xref/frameworks/base/core/java/android/widget/RelativeLayout.java" target="_blank" rel="noopener">RelativeLayout</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中，遇到了一个问题：将&lt;code&gt;RelativeLayout&lt;/code&gt;的高度从固定值180dp，修改为&lt;code&gt;wrap_content&lt;/code&gt; + &lt;code&gt;minHeight&lt;/code&gt;之后，高度为&lt;code&gt;match_parent&lt;/code&gt;的子View &lt;code&gt;LinearLayout&lt;/code&gt;在测量后就会变成&lt;code&gt;wrap_content&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
      <category term="坑" scheme="http://yoursite.com/categories/Android/%E5%9D%91/"/>
    
    
  </entry>
  
</feed>
